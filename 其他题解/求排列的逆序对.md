## 题目描述：

>在一个排列 $a$ 中，这里称 $ai​>aj​$ 且 $i<j$ 的数对为逆序对（$1≤i<j≤n$） 
>第一行**输入**包含一个正整数 $n(2≤n≤100000)$ 代表排列的长度。 
>第二行**输入** $n$ 个正整数 $ai​(1≤ai​≤n)$ 代表排列的第 i 个元素。 
>**输出** **逆序对** 的个数

*注，排列是指从 1 到 n 每个数字有且只出现 1 次的长度为 n 的数组，{3, 2, 1} 是排列，{2, 3, 1} 也是排列，{1, 3} 和 {1, 2, 3, 3} 都不是排列。

## 核心思路：

创建 **树状数组**，索引 $1$ ~ $n$， `树状数组[x]` 代表 $x - lowbit(x) + 1$ ~ $x$ 当前出现的次数

从后向前遍历原数组 (从前向后遍历也可以，逻辑都差不多，后面会给2个不同遍历顺序的代码)

核心思路以 从后向前遍历原数组 为例

每遍历一个元素 $x$，就去查 $1$ ~ $(x - 1)$ 当前出现的次数

逆序对个数 += $1$ ~ $(x - 1)$ 当前出现的次数

因为是 **从后向前** 遍历，我们要找逆序对个数，就是找右边有几个元素是比当前 $x$ **小的**

如果用双重 for循环，显然 $O(n^2)$ 会超时

这就是为什么要用 **树状数组** 这个数据结构，它的 区间和 查询是 $O(\log n)$ 的，而且它的代码实现非常简单

更新逆序对个数后，将 $x$ 出现次数 $+1$，这代表 $x$ 已经出现过 $1$ 次了，为后续遍历不出错

遍历结束，则求得结果

## AC Code

### 从后向前遍历：

```cpp
#include <bits/stdc++.h>
using ll = long long;
using namespace std;

class FenwickTree {
private:
    vector<int> tree;
    int n;
    
public:
    FenwickTree(int size) : n(size), tree(size + 1, 0) {}
    
    int lowbit(int x) {
        return x & -x;
    }

    int query(int i) {
        int ans = 0;
        while(i > 0) {
            ans += tree[i];
            i -= lowbit(i);
        }
        return ans;
    }    

    int queryRange(int l, int r) {
        return query(r) - query(l - 1);
    }

    void add(int i, int val) {
        while(i <= n) {
            tree[i] += val;
            i += lowbit(i);
        }
    }
};


int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    int n; cin >> n;
    vector<int> a(n + 1); for(int i = 1; i <= n; i++) cin >> a[i];
    FenwickTree tree(n);
    ll ans = 0;
    for(int i = n; i >= 1; i--) {
        ans += tree.query(a[i] - 1);
        tree.add(a[i], 1);
    }
    cout << ans << endl;
}
```

### 从前向后遍历：

```cpp
#include <bits/stdc++.h>
using ll = long long;
using namespace std;

class FenwickTree {
private:
    vector<int> tree;
    int n;
    
public:
    FenwickTree(int size) : n(size), tree(size + 1, 0) {}
    
    int lowbit(int x) {
        return x & -x;
    }

    int query(int i) {
        int ans = 0;
        while(i > 0) {
            ans += tree[i];
            i -= lowbit(i);
        }
        return ans;
    }    

    int queryRange(int l, int r) {
        return query(r) - query(l - 1);
    }

    void add(int i, int val) {
        while(i <= n) {
            tree[i] += val;
            i += lowbit(i);
        }
    }
};


int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    int n; cin >> n;
    vector<int> a(n + 1); for(int i = 1; i <= n; i++) cin >> a[i];
    FenwickTree tree(n);
    ll ans = 0;
    for(int i = 1; i <= n; i++) {
        ans += tree.queryRange(a[i] + 1, n);
        tree.add(a[i], 1);
    }
    cout << ans << endl;
}
```

从前向后遍历 与 从后向前遍历 不同的是：

从前向后遍历 每遍历到一个元素 $x$，就要去查比 $x$ **大的**元素当前出现的次数

即查 $(x + 1)$ ~ $n$ 当前出现的次数