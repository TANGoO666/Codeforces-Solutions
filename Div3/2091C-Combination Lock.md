## 题目链接：

https://codeforces.com/problemset/problem/2091/C

## 题目描述：

>输入测试用例的数量 $t$  
>对于每个测试用例，输入 **排列** 的长度 $n(1 ≤ n ≤ 2 * 10^{5})$    
>若长度为 $n$ 的排列在每次 **右移** 有且只有一个 **固定点**[^1]，则输出满足条件的排列 $p$，否则输出 `-1`

[^1]: 固定点满足： $p_{i} = i$ , 例如： $[3, 2, 1]$ , $p_{2} = 2$， 索引 $2$ 为固定点   

## 结论：

>*由于结论的正确性证明有些复杂，但结论很简单，所以结论的正确性证明放在后面*

如果 $n$ 为偶数，则不可能存在满足条件的排列 $p$

如果 $n$ 为奇数，则构造从大到小的 排列 $p$

## 结论的正确性证明：

### 存在性证明：

假设排列 $p$ 的索引从 $1$ 开始，右移的次数为 $k$

对于 $k$ 我们只需要讨论 $[0, (n - 1)]$ 这个范围，这是因为超过了这个范围，后续右移的情况和前面右移的情况是相等的

例如：

$[3, 2, 1]$ 第 $0$ 次右移，是 $[3, 2, 1]$

$[3, 2, 1]$ 第 $1$ 次右移，是 $[1, 3, 2]$

$[3, 2, 1]$ 第 $2$ 次右移，是 $[2, 1, 3]$

$[3, 2, 1]$ 第 $3$ 次右移，是 $[3, 2, 1]$ , 此时与第 0 次右移是**一样**的，即后续的右移 都是循环右移

因此， $k ∈ [0, (n - 1)]$

对于索引从 $1$ 开始的排列，右移 $k$ 次有如下索引公式：

$$
newIndex = (oldIndex + k - 1) \;\%\; n \; + \;1
$$

令 $newIndex = j$， $oldIndex = i$ 

则：

$$
j = (i + k - 1) \;\%\; n \; + \;1
$$

对公式变形：

$$
j - 1 = (i + k - 1) \;\%\; n \;\;\;\;(1)
$$

$$
j - 1 ≡ (i + k - 1) \;\;(mod \; n) \;\;\;\;(2)
$$

[(1) => (2)](./2091C-Combination%20Lock-proof1.md)

对 $(2)$ 化简：

$$
j ≡ i + k \;\;(mod \; n)
$$

$$
j - (i + k) = m_{i}n \;, \; m_{i} ∈ Z
$$

$$
k = j - i - m_{i}n
$$

因为每一个 $k$ 对应着 **唯一的** 固定点

因此：

$$
p_{i} = j
$$

所以：

$$
k = p_{i} - i - m_{i}n
$$

由于 $k ∈ [0, (n - 1)]$ 

所以对 $k$ 在 $[0, (n - 1)]$ 所有取值求和，得到：

$$
\dfrac{n(n - 1)}{2}
$$

因为： $k = p_{i} - i - m_{i}n \;, \; i ∈ [1, n]$ 

所以对 $p_{i} - i - m_{i}n$ 在 $[1, n]$ 求和，即为 $k$ 在 $[0, (n - 1)]$ 所有取值求和

即：

$$
\sum_{i=1}^{n} (p_{i} - i - m_{i}n) = \dfrac{n(n - 1)}{2}
$$

$$
\sum_{i=1}^{n} p_{i}\;-\;\sum_{i=1}^{n} i\;-\;n\sum_{i=1}^{n}m_{i} = \dfrac{n(n - 1)}{2}
$$

又因为 $p$ 是一个索引从 $1$ 开始的 **排列**

所以：

$$
\sum_{i=1}^{n} p_{i} = \sum_{i=1}^{n} i = \dfrac{n(n + 1)}{2}
$$

因此：

$$
-n\sum_{i=1}^{n}m_{i} = \dfrac{n(n - 1)}{2}
$$
$$
\sum_{i=1}^{n}m_{i} = -\;\dfrac{(n - 1)}{2}
$$

由于 $m_{i} ∈ Z$， 所以 $\sum_{i=1}^{n}m_{i} ∈ Z$  

所以 $-\;\dfrac{(n - 1)}{2}$ 必然也 $∈ Z$ 

所以 $(n - 1)$ 必须得是 **偶数**

因此，我们得出重要的结论： $n$ 必须是 **奇数** 

### 构造性证明：

通过上述的存在性证明，我们得到结论：排列 $p$ 的长度 $n$ 必须是 **奇数**

接下来，我们构造 **从大到小** 的排列 $p$，并证明这样构造一定符合题意

由于 **从大到小** 构造 排列 $p$， 因此排列 $p$ 的索引公式为：

$$
p_{i} = n + 1 - i
$$

例如： $[3, 2, 1]$ , $[5, 4, 3, 2, 1]$ 

由 存在性证明 提到的 右移索引公式：

$$
j = (i + k - 1) \;\%\; n \; + \;1
$$

得：

$$
n + 1 - i = (i + k - 1) \;\%\; n \; + \;1
$$

化简：

$$
n - i = (i + k - 1) \;\%\; n \;\;\;\; (3)
$$

$$
n - i ≡ (i + k - 1) \;(mod \; n) \;\;\;\; (4)
$$

[(3) => (4)](./2091C-Combination%20Lock-proof1.md) 

对 $(4)$ 化简：

$$
2i ≡ n - k + 1 \;(mod \; n)
$$

由于 $n$ 为 奇数，所以 $gcd(2, n) = 1$ 

又因为 $i ∈ [1, n]$    [根据 欧几里得引理 证明唯一解](./2091C-Combination%20Lock-proof2.md) 

因此对于每一个 $k$， $i$ 的解 **唯一**

## AC Code

``` cpp
#include <bits/stdc++.h>
using ll = long long;
using namespace std;

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    int t; cin >> t;
    while(t--) {
        int n; cin >> n;
        if(n % 2 == 0) cout << -1 << endl;
        else {
            for(int i = 1; i <= n; i++) cout << n - i + 1 << " ";
            cout << endl;
        }
    }
}
```