## 题目描述：

> 输入2个整数 a, b  
> 让 $a = a ⊕ x  (0≤x≤a)$  **$x≤$ 当前的 $a$, 而非初始的 $a$**  
> 最多进行 100次 异或操作，最终使得 `a == b`  
> 输出 **异或操作的次数** 和 **每次与 a 异或的 x**  
> 如果无法让 `a == b`，则输出 `-1`  

## 核心思路：

>*这里是整体核心思路，正确性证明及具体实现放在后面说明*

- 实际上，如果最终能够有 `a == b` 那么只需要**2次**异或操作
- 首先我们定义 $MSB(a)$ 为 a的二进制数中 **权重最高的位**
- 将 $MSB(a)$ 之后(右侧) 的 所有位的值 都变为 1
- 例如： 100110 -> 111111
- 此时 令转变后的 $a$ 记作 $a2$
- 然后 找到一个数 $x1$ 使得 $a ⊕ x1 == a2$
- 然后 找到一个数 $x2$ 使得 $a2 ⊕ x2 == b$
- 根据 异或 的性质，若 $a ⊕ b == c$，则 $c ⊕ a == b$ ， $c ⊕ b == a$
- 我们可以知道 $a2 ⊕ a == x1$， $b ⊕ a2 == x2$
- 这样 我们就得到了 $x1$ 和 $x2$


## 正确性证明及具体实现：

### 正确性证明：

#### $a ⊕ x1 == a2$ $(0≤x1≤a)$

不难证明，总是可以找到一个 $x1$，使得 $a ⊕ x1 == a2$ $(0≤x1≤a)$

假设 一个二进制数的 $MSB$ 是 $n$，并且这个数 $n$之后(右侧) 所有位的值 都为 0
那么 这个数的 十进制值 可以表示成 $2^n$

另外一个二进制数的 $MSB$ 是 $n-1$，并且这个数 $n-1$之后(右侧) 所有位的值 都为 1
那么 这个数的 十进制值 可以表示成 $2^n - 1$

显然 $2^n > 2^n - 1$

这意味着 $(1000000...000)2$ 肯定是 **大于** $(0111111...111)2$ 的

那么 如果 $(1000000...000)2$ 在 $MSB$ 之后(右侧) 有某些位的值 为 1
例如： $(1000000...010)2$，必然也 大于 $(0111111...111)2$

那么，让我们回到  $a ⊕ x1 == a2$ $(0≤x1≤a)$

$a2$ 是 将 $MSB(a)$ 之后(右侧) 的 所有位的值 都变为 1 之后 $a$ 的新值
这通过 $a ⊕ x1$ 实现

根据 异或的性质 **相同为0，不同为1**， $x1$ 在 $MSB(a)$ 处的值肯定要为 0

再结合上述证明，很显然， $x1$ 一定满足 $0≤x1≤a$

#### $a2 ⊕ x2 == b$ $(0≤x2≤a2)$

我们再来讨论 总是可以找到一个 $x2$，使得 $a2 ⊕ x2 == b$ $(0≤x2≤a2)$

由 $a2 ⊕ x2 == b$，则有 $b ⊕ a2 == x2$

此时 a2 是 $MSB(a)$ 之后(右侧) 的 所有位的值 都变为 1 之后 $a$ 的新值

很显然，这些位都为 1 ，不管和怎样的二进制数进行 异或

得到的结果都不会超过自身

当然，这里其实对 $b$ 是有要求的： $b$ 的 前导零数量 $≥$ $a$ 的 前导零数量

这点会在后面的 具体实现 细说

### 具体实现

首先，我们得知道一个函数：`__builtin_clz()`

它返回 **前导零** 的个数

例如传入 `int` 类型参数 `z == 1`

那么 `__builtin_clz(z) == 31`

根据题目要求，如果 $MSB(b) > MSB(a)$，那么我们可以直接返回 -1

这是因为 如果要使 $a$ 在 $MSB(b)$ 上的 0 变成 1，那么要选择与 $a$ 异或 的 $x$ 必然会 大于 $a$，这显然不符合题目要求： $(0≤x≤a)$

$MSB(b) > MSB(a)$ 等价于 `__builtin_clz(b) < __builtin_clz(a) `

举个例子： `__builtin_clz(b) == 2`，`__builtin_clz(a) == 3`
那么很直观能发现 b： $(001................)2$， a： $(0001................)2$
$MSB(b) > MSB(a)$

那么接下来，只需要考虑 $MSB(b) ≤ MSB(a)$ 的情况了

根据核心思路， $x1$ 很容易就能求得： $a2 ⊕ a == x1$

只需要知道 $a2$ 就可以， $a2$ 是 将 $MSB(a)$ 之后(右侧) 的 所有位的值 都变为 1 之后 $a$ 的新值

那么其实 $2^{MSB(a)+1}  - 1$ 就是 $a2$ 的值

举个例子：假设 $MSB(a)$ 为 3，要使 $(000...01000)2$ -> $(000...01111)2$

就是让 $(000...10000)2 - 1$，这就是 $2^{MSB(a)+1}  - 1$

那怎么求 $MSB(a)$ 呢？

`__builtin_clz(a)` 可以求 $a$ 的 前导零数量，`int` 类型变量占 32位（0~31）

所以 $MSB(a)$ == `31 - __builtin_clz(a)`

所以 $a2$ == $2^{31 - \mathrm{builtinclz}(a) + 1} - 1$ == $2^{32 - \mathrm{builtinclz}(a)} - 1$

因此，可以用 左移运算符 表示 `a2 == ((1 << 32 - __builtin_clz(a)) - 1)`

有了 $a2$，根据 $a2 ⊕ a == x1$，就能求出 $x1$

再根据 $b ⊕ a2 == x2$， 就能求出 $x2$

## AC Code

```cpp
#include <bits/stdc++.h>
using ll = long long;
using namespace std;

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    int t; cin >> t;
    while(t--) {
        int a, b; cin >> a >> b;
        if(__builtin_clz(a) > __builtin_clz(b)) cout << "-1" << endl;
        else {
            vector<int> ans; ans.push_back(a ^ ((1 << 32 - __builtin_clz(a)) - 1));
            ans.push_back(b ^ ((1 << 32 - __builtin_clz(a)) - 1));
            cout << ans.size() << endl;
            for(auto& x : ans) cout << x << " ";
            cout << endl;
        }
    }
}
```
